#' Function to reconstruct individual patient data (IPD) from Kaplan-Meier (KM) 
#' survival curves based on P. Guyot et al. Enhanced secondary analysis of survival 
#' data: 
#' reconstructing the data from published Kaplan-Meier survival curves, 2012
#' The function returns the reconstructed individual patient data (IPD) based on 
#' digitized data from Kaplan-Meier (KM) survival curves, and a dataframe with the 
#' time points or intervals at which the K-M estimates are calculated,
#' estimated number of patients at risk at each time point,
#' estimated number of events (occurrences of the event) at each time point, and
#' the estimated number of censored observations at each time point. 
#'
#' @param time A vector of the x coordinates of the survival times.
#' @param prob A vector of the y coordinates corresponding to `time`, between 0 and 1. 
#' These represent survival probabilities at the times in `time`.
#' @param trisk A vector of times at which patients are at risk.
#' @param nrisk A vector of the number of patients at risk.
#' @param lower A vector that contains the lower time limits for each interval. 
#' It defines the starting point of each interval where calculations for survival 
#' estimates and events will be made. 
#' @param upper A The `upper` parameter is also a vector that contains the upper 
#' time limits for each interval. 
#' It defines the end point of each interval where calculations will stop. 
#' @param tot_events The number total events (optional).
#' @return A list with four data.frames, one data.frame of reconstructed IPD with two columns: 
#' (1) time: survival time, (2) event: indicator of event, where 1=event and 0=censored, 
#' a data.frame with estimated parameter values, a data.frame with survival times and 
#' probabilities, potentially modified to fix non-decreasing survival probabilities,
#' and a data.frame with details in the itme intervals.
#' @export
get_ipd_guyot <- function(time, 
                          prob, 
                          trisk,  
                          nrisk, 
                          lower,
                          upper,
                          tot_events = NA) {
  delta <- 0.1
  if (max(prob) > (1 + delta)) {
    stop('Survival probabilities should not be bigger than 1!')
  } else {
    # We apply a basic fix.
    prob[prob > 1] <- 1
  }
  
  # As a default, sort survival time.
  time <- sort(time)
  
  # We apply a basic fix if survival probabilities are increasing.
  df_input <- fix_non_decreasing_survival_probabilities(time, prob)
  time <- df_input$time
  prob <- df_input$prob
  
  # Validate input.
  validation_input_guyot(time, prob, trisk, nrisk, lower, upper, tot_events)
  
  df_time <- prepare_time_interval_data(time, trisk, nrisk, lower, upper)
  
  # Initialise variables and vectors.
  n_int <- length(nrisk)
  n_t <- upper[n_int]
  n_censor <- rep(0,(n_int-1)) # estimated number of patients censored
  n_hat <- rep(nrisk[1]+1,n_t) # estimated number of patients at risk
  cen <- rep(0,n_t) # censored observations
  d <- rep(0,n_t) # estimated number of events
  KM_hat <- rep(1,n_t) # Estimation of KM survival probability
  last_i <- rep(1,n_int)
  sumdL <- 0
  
  if (n_int > 1) {
    # This is the for loop which goes over all time intervals.
    # Time intervals: 1,...,(n_int-1).
    for (i in 1:(n_int-1)) {
      # First approximation of number of censored patients on interval i.
      n_censor[i] <- round(nrisk[i] * prob[lower[i+1]] / prob[lower[i]] - nrisk[i+1])
      # Adjust total number of censored patients until n_hat = nrisk at start of interval (i+1).
      while((n_hat[lower[i+1]] > nrisk[i+1]) || ((n_hat[lower[i+1]] < nrisk[i+1]) && (n_censor[i] > 0))) {
        if (n_censor[i] <= 0) {
          cen[lower[i]:upper[i]] <- 0
          n_censor[i] <- 0
        }
        if (n_censor[i] > 0) {
          # cen_t: vector of censored time points.
          # The censored time points are generated by evenly distributing the 
          # censored patients over the time interval.
          cen_t <- rep(0,n_censor[i]) 
          for (j in 1:n_censor[i]) {
            cen_t[j] <- time[lower[i]] + j * (time[lower[(i+1)]] - time[lower[i]]) / (n_censor[i]+1)
          }
          # Distribute censored observations evenly over time. 
          # Find number of censored patients on each time interval.
          cen[lower[i]:upper[i]] <- hist(cen_t,breaks=time[lower[i]:lower[(i+1)]],plot=F)$counts
        }
        # Find number of events and number of patients at risk on each interval 
        # to agree with KM estimates read from curves.
        n_hat[lower[i]] <- nrisk[i]
        last <- last_i[i]
        for (k in lower[i]:upper[i]) {
          if (i==1 & k==lower[i]) {
            d[k] <- 0
            KM_hat[k] <- 1
          } else {
            # The line below calculates the number of events at time 
            # k by multiplying the number of people at risk at time k (n_hat[k]) 
            # by the probability of not experiencing the event up to 
            # time k (1 - (prob[k] / KM_hat[last])). 
            # The probability of not experiencing the event up to time 
            # k is calculated using the Kaplan-Meier estimate of the 
            # survival function up to time k (KM_hat[last]).
            # The round() function is used to round the number of events 
            # to the nearest integer. 
            # This is because the number of events can be a non-integer 
            # due to rounding errors in the calculation of the Kaplan-Meier estimate.
            d[k] <- round(n_hat[k] * (1 - (prob[k] / KM_hat[last])))
            KM_hat[k] <- KM_hat[last] * (1 - (d[k] / n_hat[k]))
          }
          n_hat[k+1] <- n_hat[k] - d[k] - cen[k]
          if (d[k] != 0) {
            last <- k
          }  
        } # end for loop: or (k in lower[i]:upper[i]) {...}
        
        # Adjust the estimated number of censored patients in the time interval i 
        # to account for the difference between the estimated number of patients 
        # at risk at the end of time interval i and the actual number of patients 
        # at risk at the start of time interval i+1
        n_censor[i] <- n_censor[i] + (n_hat[lower[i+1]] - nrisk[i+1])
        
        # Vincent: Added break out code below to avoid infinite looping
        # in case where we have input that triggers the while loop not 
        # to reach termination.
        if (i == (n_int-1)) {
          break
        }
        
      } # end of while loop.
      if (n_hat[lower[i+1]] < nrisk[i+1]) {
        nrisk[i+1] <- n_hat[lower[i+1]]
      }  
      last_i[(i+1)] <- last
    } # end of for loop: Time intervals 1,...,(n_int-1)
  } # if (n_int > 1)
  
  # Time interval n_int.
  if (n_int > 1) {
    # Assume same censor rate as average over previous time intervals.
    val <- sum(n_censor[1:(n_int-1)]) * (time[upper[n_int]] - time[lower[n_int]]) / (time[upper[(n_int-1)]] - time[lower[1]])
    n_censor[n_int] <- min(round(val), nrisk[n_int])
  }
  
  if (n_int == 1) {
    n_censor[n_int] <- 0
  }
  
  if (n_censor[n_int] <= 0) {
    cen[lower[n_int]:(upper[n_int]-1)] <- 0
    n_censor[n_int] <- 0
  }
  
  if (n_censor[n_int] > 0) {
    cen_t <- rep(0,n_censor[n_int])
    for (j in 1:n_censor[n_int]) {
      cen_t[j] <- time[lower[n_int]] + j * (time[upper[n_int]] - time[lower[n_int]]) / (n_censor[n_int]+1)
    }
    cen[lower[n_int]:(upper[n_int]-1)] <- hist(cen_t, breaks=time[lower[n_int]:upper[n_int]],plot=F)$counts
  }
  
  # Find number of events and number of patients at risk on each interval to 
  # agree with KM estimates read from curves.
  n_hat[lower[n_int]] <- nrisk[n_int]
  last <- last_i[n_int]
  for (k in lower[n_int]:upper[n_int]) {
    if (KM_hat[last] != 0) {
      d[k] <- round(n_hat[k] * (1 - (prob[k] / KM_hat[last])))
    } else {
      d[k] <- 0
    }
    KM_hat[k] <- KM_hat[last] * (1 - (d[k] / n_hat[k]))
    n_hat[k+1] <- n_hat[k] - d[k] - cen[k]
    # No. at risk cannot be negative.
    if (n_hat[k+1] < 0) {
      n_hat[k+1] <- 0
      cen[k] <- n_hat[k] - d[k]
    }
    if (d[k] != 0) { 
      last <- k
    }  
  }
  # If total number of events reported, adjust number of censored patients so 
  # that total number of events agrees.
  if (!is.na(tot_events)) {
    if (n_int > 1) {
      sumdL <- sum(d[1:upper[(n_int-1)]])
      # If total no. events already too big, then set events and censoring = 0 
      # on all further time intervals.
      if (sumdL >= tot_events) {
        d[lower[n_int]:upper[n_int]] <- rep(0,(upper[n_int] - lower[n_int]+1))
        # Vincent: Added case distinction in case we have indices of same 
        # value at the end in lower and upper.
        if (lower[n_int] == upper[n_int]) {
          cen[lower[n_int]:upper[n_int]] <- rep(0,1)
        } else {
          cen[lower[n_int]:(upper[n_int] - 1)] <- rep(0,(upper[n_int] - lower[n_int]))    
        }
        n_hat[(lower[n_int] + 1):(upper[n_int] + 1)] <- rep(nrisk[n_int], (upper[n_int] + 1 - lower[n_int]))
      }
    }
    # Otherwise adjust no. censored to give correct total no. events.
    if ((sumdL < tot_events) || (n_int==1)) {
      sumd <- sum(d[1:upper[n_int]])
      while ((sumd > tot_events) || 
             ((sumd < tot_events) && (n_censor[n_int] > 0))) {
        n_censor[n_int] <- n_censor[n_int] + (sumd - tot_events)
        if (n_censor[n_int] <= 0) {
          cen[lower[n_int]:(upper[n_int] - 1)] <- 0
          n_censor[n_int] <- 0
        }
        if (n_censor[n_int] > 0) {
          cen_t <- rep(0,n_censor[n_int])
          for (j in 1:n_censor[n_int]) {
            cen_t[j] <- time[lower[n_int]] + j * (time[upper[n_int]] - time[lower[n_int]]) / (n_censor[n_int]+1)
          }         
          cen[lower[n_int]:(upper[n_int]-1)] <- hist(cen_t,breaks=time[lower[n_int]:upper[n_int]], plot=F)$counts
        }
        n_hat[lower[n_int]] <- nrisk[n_int]
        last <- last_i[n_int]
        for (k in lower[n_int]:upper[n_int]) {
          d[k] <- round(n_hat[k] * (1 - (prob[k] / KM_hat[last])))
          KM_hat[k] <- KM_hat[last] * (1 - (d[k] / n_hat[k]))
          if (k != upper[n_int]) {
            n_hat[k+1] <- n_hat[k] - d[k] - cen[k]
            # No. at risk cannot be negative.
            if (n_hat[k+1] < 0) {
              n_hat[k+1] <- 0
              cen[k] <- n_hat[k] - d[k]
            }
          }
          if (d[k] != 0) {
            last <- k
          }  
        }
        sumd <- sum(d[1:upper[n_int]])
      }
    }
  } # if (!is.na(tot_events))
  
  # Explanation of columns in km_mat:
  #
  # t_s: 
  # This column represents the time points or intervals at which the K-M estimates are calculated. 
  # It provides the specific time values for each interval.
  #
  # n_estimate: 
  # This column represents the estimated number of patients at risk at each time point. 
  # It indicates the number of individuals who have not experienced the event 
  # (i.e., still at risk) up to that specific time point.
  #
  # d_estimate: 
  # This column represents the estimated number of events (occurrences of the event) at each time point. 
  # It indicates the number of individuals who experienced the event at that specific time point.
  #
  # censoring_estimate: 
  # This column represents the estimated number of censored observations at each time point. 
  # Censored observations are cases where the event hasn't occurred yet, and the data is right-censored. 
  # It indicates the number of individuals who were still at risk but were censored (their event status 
  # is unknown) at that specific time point.
  
  km_mat <- matrix(c(time, n_hat[1:n_t], d, cen), ncol=4, byrow=F)
  km_mat <- as.data.frame(km_mat)
  names(km_mat) <- c('t_s','n_estimate','d_estimate','censoring_estimate')
  
  # Now create IPD.
  # Initialise vectors.
  t_IPD <- rep(time[n_t], nrisk[1])
  event_IPD <- rep(0, nrisk[1])
  
  # Get event time and event indicator (=1) for each event, as separate row 
  # in t_IPD and event_IPD
  k <- 1
  for (j in 1:n_t) {
    # Vincent: added code below since d can contain negative values and
    # we need positive values.
    #if (d[j] != 0) {
    if (d[j] > 0) {  
      t_IPD[k:(k+d[j]-1)] <- rep(time[j],d[j])
      event_IPD[k:(k+d[j]-1)] <- rep(1,d[j])
      k <- k + d[j]
    }
  }
  # Get censor time and event indicator (=0) for each censor, as separate row 
  # in t_IPD and event_IPD.
  for (j in 1:(n_t - 1)) {
    if (cen[j] != 0) {
      t_IPD[k:(k+cen[j]-1)] <- rep(((time[j]+time[j+1])/2),cen[j])
      event_IPD[k:(k+cen[j]-1)] <- rep(0,cen[j])
      k <- k + cen[j]
    }
  }
  # Output IPD.
  IPD <- matrix(c(t_IPD,event_IPD), ncol=2, byrow=F)
  IPD <- as.data.frame(IPD)
  names(IPD) <- c('time','event')
  return(list(IPD, km_mat, df_input, df_time))
}
